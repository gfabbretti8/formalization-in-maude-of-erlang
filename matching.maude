***(

	MATCHING.MAUDE

	In this file we implement the pattern matching code. Both Maude modules
	that are defined here are functional modules. This is important as they
	are used within the conditions of the equations of the underlying
	equational theory.

	First, ordinary pattern matching is specified in the SEM_MATCH functional
	module. The #match operation takes a pattern and a constant and tries to
	match the pattern against the constant.
	
	Second, the SEM_MATCH_MAILBOX functional module defines the more subtle
	operations needed to match the clauses of a receive statement against
	the contents of a mailbox.
	The reception of messages is more complicated as it uses two levels
	of recursion: The clauses are recursively matched against the first
	message in the mailbox; if there is no match, the clause list is
	again matched against the remaining messages. The recursion terminates
	when the first match is found or every message of the mailbox has failed
	to match any clause.
	As the clauses may contain guards (additional conditions that control 
	if the clause may be evaluated in case of a matching pattern), we need the
	equational theory to evaluate the guard expressions. Note however,
	that according to the Core-Erlang semantics, there must not occur any 
	system level transitions during the evaluation of a guard (i.e. no send
	or receive statements, etc). Therefore the equational theory suffices
	and we never have to switch to the rewriting rules of the system level.

***)

fmod SEM_MATCH is
	protecting SYNTAX .


	*** As most of the pattern matching operations are partial functions
	*** because of possible matching failures, we declare an error supersort of Env:
  sort Env .
  op #not-empty-env : -> Env [ctor] .
	op #empty-env : -> Env [ctor] .
	op _,_ : Env Env -> Env [ctor assoc comm id: #empty-env prec 60] .
	sort Env? .
	subsort Env < Env? .

	*** The #nomatch constructor indicates the failure of a matching
	*** operation. If it is included in a variable environment and since
	*** it is not of sort Env, the resulting term is of kind [Env?].
	*** In this way, we distinguish between successful and unsuccessful
	*** matching operations.
	op #nomatch : -> Env? [ctor] .

	*** The #match operation tries to match the given pattern with the
	*** constant provided as second argument. Because there may be many
	*** variables that have to be bound to unify the two terms, the
	*** result term is of sort Env (and not just a single Binding).
	op #match : Pattern Literal ~> Env .


	var LIT : Literal .
	var PATSEQ : Pattern .
	vars PAT PAT1 PAT2 : Pattern .
	vars L L1 L2 : Literal .


	*** The second case: Two identical terms are unified (without the need to
	*** bind any variables)
	*** Note: The cases of matching two empty lists [] or two 0-ary tuples {}
	***       are implicitly covered here, too.
	eq #match(LIT, LIT) = #not-empty-env .

	*** A pattern may be a list. Therefore we match a list of patterns
	*** against a list of constants by pairwise matching the list elements.
	eq #match([PAT1 | PAT2], [L1 | L2]) = #match(PAT1, L1), #match(PAT2, L2) .


	*** All other cases lead to an incorrect matching.
	eq #match(PAT, LIT) = #nomatch [owise] .

endfm




fmod SEM_MATCH_MAILBOX is
	extending SYNTAX .
	protecting SEM_MATCH .
	protecting SEM_PROCESS .
  protecting SEM_MAILBOX .
	*** During the receive operation, we have to try to match each of the clauses in the
	*** receive statement against every message (i.e. constant) in the process' mailbox.
	*** The messages are processed in a FIFO manner. The algorithm is as follows:
	*** 1. Try matching the clauses of the receive statement against the first message
	***    Stop as soon as a matching clause is found.
	*** 2. Try to evaluate its guard expression. If it evaluates to the Core-Erlang
	***    atom 'true', the matching is successful.
	*** 3. If no clause matches the first message (in the sense of 1 and 2), remember the
	***    first message and proceed with the rest of the mailbox (go back to 1).
	*** 3. Matching fails, if no match is found and all messages have been tested.
	*** 4. If matching succeeds, return the matching clause's right hand expression
	***    and the mailbox without the received message.
	*** Note: The specification here deeply relies on Maude's ability to do matching
	***       modulo associativity and identity-elements. See the definition of the
	***	  process-mailbox within the SEM_MAILBOX functional module for more
	***	  information.


	*** The result of a mailbox-matching operation is represented by terms of sort
	*** ClauseMatchResult.
	sort ClauseMatchResult .

  op #empty-clauselist : -> ClauseSeq .
  
	*** The external interface for the matching operation is the 3ary #mailboxMatch
	*** operation. Its arguments are
	*** 1. The clause list of the receive statement
	*** 2. The mailbox of the process
	op #mailboxMatch(_|_) : ClauseSeq Mailbox -> ClauseMatchResult .

	*** The matching operation is performed internally by the #mailboxMatch function:
	*** Its arguments are as follows:
	*** 1. The unaltered list of all clauses in the receive statement
	***    (need to be remembered during recursion!)
	*** 2. The unaltered list of all messages in the process' mailbox
	***    (need to be remembered during recursion!)
	*** 3. The clauses that must still be matched against the current message
	***    (if matching fails, the corresponding clause is removed from this list)
	*** 5. The messages which still have to be checked
	op #mailboxMatch(_|_|_) : ClauseSeq ClauseSeq Mailbox -> ClauseMatchResult .

	*** The #mailboxMatchSuccess term represents a successful matching. It consists of
	*** 1. The expression on the rhs of the matching clause
	***    Free occurrences of variables that became bound by the matching operation are
	***    already substituted by their corresponding values.
	*** 2. The message that matched and was removed from the mailbox.
	op #mailboxMatchSuccess(_|_) : Exp Literal -> ClauseMatchResult [ctor] .

	*** Failure of the matching operation is indicated by the #mailboxMatchFailure
	*** constant:
	op #mailboxMatchFailure : -> ClauseMatchResult [ctor] .

	*** The #extractMessage operation removes the first occurrence of the message
	*** that is given in the 2nd argument from the mailbox.
	op #extractMessage(_|_) : Mailbox Message -> Mailbox .
	op #extractMessage(_|_|_) : Mailbox Message Mailbox -> Mailbox .

	var CLAUSE : Clause .
	var NECLLIST : ClauseSeq .
	vars CLAUSES CLAUSES1 : ClauseSeq .
	var PAT : Pattern .
	vars EX EX1 : Exp .
	vars MBOX MBOX1 MBOX2 : Mailbox .
	vars ENV : Env .
	vars LIT LIT1 : Literal .
	var GUARD : Exp .
  vars P P' : Pid .

	*** Initialisation step for the matching operation
	*** We start with the entire mailbox and the complete list of clauses.
	eq #mailboxMatch(CLAUSES | MBOX) =
	    #mailboxMatch(CLAUSES | CLAUSES | MBOX) .

	*** If the mailbox is empty, we return a matching failure immediately.
	eq #mailboxMatch(CLAUSES | CLAUSES1 | #empty-mbox) = #mailboxMatchFailure .

	*** The current clause does not match the current message (constant).
	*** We delete the clause and continue with the
	*** next clause in the clauselist.
	*** Note: The case of only one clause in the clauselist is covered by this rule
	***       due to the identity declaration of the #empty-clauselist constant. A
	***       clauselist consisting of one clause only unifies with the pattern CLAUSE CLAUSES1
	***       by substituting CLAUSES1 by the identity-element #empty-clauselist.
	ceq #mailboxMatch(CLAUSES | CLAUSE ; CLAUSES1 | {P, LIT} :: MBOX2) =
            #mailboxMatch(CLAUSES | CLAUSES1 | {P, LIT} :: MBOX2)
		if (PAT -> EX) := CLAUSE
		/\ not(#match(PAT, LIT) :: Env) .


	*** The current message matches the current clause and the condition (guard) can
	*** be evaluated to atom("true"). In this case we stop and return #mailboxMatchSuccess
	ceq #mailboxMatch(CLAUSES | CLAUSE ; CLAUSES1 | {P, LIT} :: MBOX2) =
	    #mailboxMatchSuccess(EX | LIT)
		if (PAT  -> EX) := CLAUSE
		/\ ENV := #match(PAT, LIT) .

	*** If none of the clauses matched the current message, we consider the next message
	*** in the mailbox (w.r.t. the complete clause list). The old head element of the
	*** mailbox is forgotten.
	*** Note: There are no more clauses in the clause list. The case of a one-elementary
	***       clause list is covered by the rules above together with the identity declaration
	***       of the _,_ : ClauseList ClauseList -> ClauseList operator.
	eq #mailboxMatch(CLAUSES | #empty-clauselist | {P, LIT} :: MBOX2) =
 	   #mailboxMatch(CLAUSES | CLAUSES | MBOX2) .


	eq #extractMessage(MBOX | {P, LIT}) = #extractMessage(#empty-mbox | {P, LIT} | MBOX) .
	eq #extractMessage(MBOX1 | {P, LIT} | {P, LIT} :: MBOX2) = MBOX1 :: MBOX2 .
	eq #extractMessage(MBOX1 | {P, LIT} | #empty-mbox) = MBOX1 .
	eq #extractMessage(MBOX1 | {P, LIT} | {P, LIT1} :: MBOX2)
	       = #extractMessage(MBOX1 :: {P, LIT1} | {P, LIT} | MBOX2) [owise] .
endfm
