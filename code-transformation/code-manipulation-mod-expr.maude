
  set show loop stats off .
  set show loop timing off .
  set show advisories off .

  fmod CODE-MANIPULATION-BANNER is
    pr STRING .
    op code-manipulation-banner : -> String .
    eq code-manipulation-banner
      = "CODE-MANIPULATION mod. expr. available Aug. 26th 2021" .
  endfm

  fmod CODE-MANIPULATION-SIGN is
    ex FULL-MAUDE-SIGN .
    op CODE-MANIPULATION`[_`] : @ModExp@ -> @ModExp@ .
  endfm

  fmod CODE-MANIPULATION-META-SIGN is
    pr META-LEVEL .
    pr META-FULL-MAUDE-SIGN .
    pr FM-UNIT .

    op CODE-MANIPULATION-GRAMMAR : -> FModule .

    eq CODE-MANIPULATION-GRAMMAR
      = addImports((including 'CODE-MANIPULATION-SIGN .), GRAMMAR) .
  endfm

  fmod CODE-MANIPULATION-EXPR is
    inc MOD-EXPR .
    pr FM-INST-EXPR-EVALUATION .
    pr FM-EVALUATION .
    pr CODE-MANIPULATION .
    pr FM-MOD-EXP-PARSING .

    vars N N' : NzNat .
    var  PDL : ParameterDeclList .
    vars DB DB' : Database .
    vars T T' T'' : Term .
    var  IL : ImportList .
    var  VEPS : Set{Tuple{ViewExpression,ViewExpression}} .
    var  X : Qid .
    var  S : Sort .
    vars ME ME' : ModuleExpression .
    var  DT : Default{Term} .
    vars U U' M DM : Module .
    vars MNS MNS' MNS'' MNS3 MNS4 : Set{ModuleName} .
    vars VES VES' : Set{ViewExpression} .
    var  MIS : Set{ModuleInfo} .
    var  VIS : Set{ViewInfo} .
    var  QIL : QidList .
    var  VDS : VariableSet .

  *** As for TUPLE, the equation for the \texttt{evalModExp} is reduced to the
  *** creation of a new module. A module expression POW[n]{Nat} produces a
  *** module
  ***
  *** fmod POW[n]{X :: TRIV} is
  ***   inc TUPLE[n]{X, X, ..., X} .
  *** endfm
  ***
  *** which is then instantiated by the Nat view.

  *** Some auxiliary functions are defined in order
  *** to generate the different declarations in the module.

    op CODE-MANIPULATION`[_`] : ModuleExpression -> ModuleExpression .

    ceq evalModExp(CODE-MANIPULATION[ME], PDL, DB)
      = if unitInDb(CODE-MANIPULATION[ME], DB')
        then < DB' ; CODE-MANIPULATION[ME] >
        else < evalModule(
                 setName(
                   #transform-mod(upModule(ME',false)),
                   CODE-MANIPULATION[ME]),
                 none, DB') ;
               CODE-MANIPULATION[ME] >
        fi
      if ME' := modExp(evalModExp(ME, PDL, DB))
         /\ DB' := database(evalModExp(ME, PDL, DB)) [print "ciao2" ] .

  *** The equations for the \texttt{header2QidList},
  *** \texttt{parseModExp}, \texttt{prepHeader}, and
  *** \texttt{setUpModExpDeps} functions on the $n$-tuple module
  *** expression are as follows:

    eq parseModExp('CODE-MANIPULATION`[_`][T])
      = CODE-MANIPULATION[parseModExp(T)] .

    eq solveUps('upModule['CODE-MANIPULATION`[_`][T]], DB)
      = solveUpsModExp('upModule['CODE-MANIPULATION`[_`][T]], DB) .

    eq solveUps('upTerm['CODE-MANIPULATION`[_`][T], 'bubble[T'']], DB)
      = solveUpsModExp('upTerm['CODE-MANIPULATION`[_`][T], 'bubble[T'']], DB) .

    eq labelInModExp(X, CODE-MANIPULATION[ME]) = false .

    eq header2Qid(CODE-MANIPULATION[ME])
      = qid("CODE-MANIPULATION[" + string(header2Qid(ME)) + "]") .

    eq header2QidList(CODE-MANIPULATION[ME])
      = ('CODE-MANIPULATION '`[ header2QidList(ME) '`]) .

    eq prepModExp(CODE-MANIPULATION[ME], VEPS)
      = CODE-MANIPULATION[prepModExp(ME, VEPS)] .

    eq setUpModExpDeps(CODE-MANIPULATION[ME],
         db(< ME ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS,
            MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
      = db(< ME ; DT ; U ; U' ; M ; VDS ; MNS . CODE-MANIPULATION[ME] ; VES > MIS,
           MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .

    eq setUpModExpDeps(CODE-MANIPULATION[ME],
         db(< ME ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS,
            MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
      = db(< ME ; DM ; U ; U' ; M ; VDS ; MNS . CODE-MANIPULATION[ME] ; VES > MIS,
           MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .

    eq setUpModExpDeps(CODE-MANIPULATION[ME], DB)
      = warning(DB,
          '\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n)
      [owise] .
  endfm

*** Redefinition of the FULL-MAUDE module. The init rule now creates an
*** instance of class Unifier. The init rule now takes Unifier objects, and for them
*** it uses UNIFICATION-GRAMMAR instead of GRAMMAR to parse inputs.

mod FULL-MAUDE is
  pr FM-DATABASE-HANDLING .
  inc LOOP-MODE .
  pr FM-BANNER .
  pr CODE-MANIPULATION-META-SIGN .
  pr CODE-MANIPULATION-BANNER .
  pr CODE-MANIPULATION-EXPR .

  subsort Object < State .

  sort CodeManipulation .
  subsort CodeManipulation < DatabaseClass .
  op CodeManipulation : -> CodeManipulation .

  op o : -> Oid .
  op init : -> System .

  var  Atts : AttributeSet .
  var  X@CodeManipulation : DatabaseClass .
  var  O : Oid .
  var  DB : Database .
  var  ME : Header .
  var  QI : Qid .
  vars QIL QIL' QIL'' : QidList .
  var  TL : TermList .
  var  N : Nat .
  vars RP RP' : ResultPair .

  rl [init] :
     init
     => [nil,
         < o : CodeManipulation |
            db : initialDatabase,
            input : nilTermList, output : nil,
            default : 'CONVERSION >,
         ('\t string2qidList(code-manipulation-banner) '\n)] .

  rl [in] :
    [QI QIL,
     < O : X@CodeManipulation |
         db : DB, input : nilTermList, output : nil, default : ME, Atts >,
     QIL']
    => if metaParse(CODE-MANIPULATION-GRAMMAR, QI QIL, '@Input@) :: ResultPair
       then [nil,
             < O : X@CodeManipulation | db : DB,
                 input : getTerm(metaParse(CODE-MANIPULATION-GRAMMAR, QI QIL, '@Input@)),
                 output : nil, default : ME, Atts >,
              QIL']
       else [nil,
             < O : X@CodeManipulation | db : DB, input : nilTermList,
                 output : ('\r 'Warning:
                           printSyntaxError(
                             metaParse(CODE-MANIPULATION-GRAMMAR, QI QIL, '@Input@),
                             QI QIL)
                           '\n
                           '\r 'Error: '\o 'No 'parse 'for 'input. '\n),
                 default : ME, Atts >,
             QIL']
       fi .

  rl [out] :
    [QIL,
     < O : X@CodeManipulation |
         db : DB, input : TL, output : (QI QIL'), default : ME, Atts >,
     QIL'']
    => [QIL,
        < O : X@CodeManipulation |
            db : DB, input : TL, output : nil, default : ME, Atts >,
        (QI QIL' QIL'')] .
endm

loop init .

trace exclude FULL-MAUDE .

set show loop stats on .
set show loop timing on .
set show advisories on .

---(
---(
  $ maude.linux full-maude.maude deadlock-free-mod-expr.maude
             \||||||||||||||||||/
           --- Welcome to Maude ---
             /||||||||||||||||||\
        Maude 2.4 built: Sep 24 2008 13:12:22
        Copyright 1997-2008 SRI International
           Thu Oct 30 18:21:36 2008

        Full Maude 2.4. September 24th 2008


    CODE-MANIPULATION mod. expr. available Oct. 28th 2008
---)
  load model-checker.maude
  load bakery.maude

  select FULL-MAUDE .
  loop init .

---(
  rewrites: 184 in 0ms cpu (2ms real) (~ rewrites/second)
	CODE-MANIPULATION mod. expr. available Oct. 28th 2008
---)

  (mod DF-BAKERY is
     protecting CODE-MANIPULATION[BAKERY, BState] .
   endm)

---(
  rewrites: 3788 in 20ms cpu (32ms real) (189400 rewrites/second)
  Introduced module DF-BAKERY
---)

  (show rls DF-BAKERY .)

---(
rewrites: 259 in 30ms cpu (33ms real) (8633 rewrites/second)

  crl {V:BState}
    => {V:BState}
    if enabled(V:BState)=/= true = true .
  rl < P:Mode,0,wait,Y:Nat >
    => < P:Mode,0,crit,Y:Nat > [label p2_wait] .
  rl < P:Mode,X:Nat,crit,Y:Nat >
    => < P:Mode,X:Nat,sleep,0 > [label p2_crit] .
  rl < P:Mode,X:Nat,sleep,Y:Nat >
    => < P:Mode,X:Nat,wait,s X:Nat > [label p2_sleep] .
  rl < crit,X:Nat,Q:Mode,Y:Nat >
    => < sleep,0,Q:Mode,Y:Nat > [label p1_crit] .
  rl < sleep,X:Nat,Q:Mode,Y:Nat >
    => < wait,s Y:Nat,Q:Mode,Y:Nat > [label p1_sleep] .
  rl < wait,X:Nat,Q:Mode,0 >
    => < crit,X:Nat,Q:Mode,0 > [label p1_wait] .
  crl < P:Mode,X:Nat,wait,Y:Nat >
    => < P:Mode,X:Nat,crit,Y:Nat >
    if Y:Nat < X:Nat = true [label p2_wait] .
  crl < wait,X:Nat,Q:Mode,Y:Nat >
    => < crit,X:Nat,Q:Mode,Y:Nat >
    if not Y:Nat < X:Nat = true [label p1_wait] .
---)
---)
