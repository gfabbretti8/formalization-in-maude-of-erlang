***(

	LOOP.MAUDE

	In this module we define the LOOP-MODE interface for user interaction on the
	command line of the Maude interpreter.

	In the functional module COMMAND-GRAMMAR, we specify a set of commands that can
	be used from within the Maude command line to control the actions of the system:
		* loading a Core-Erlang source file
		* specifying a statement and computing the states
		* starting the model checker

	To output the states that are computed, we define the STATESPACE-OUTPUT functional
	module. It calculates all the states and outputs them correspondingly.

	The ERLANG-LOOP module finally implements the interface to Maude's input/output
	subsystem and defines rewriting rules that implement the commands.
	Note: The model checker uses the equational theory and the rewriting theory of
	      the module in which it is started; therefore our theory has to be included
	      into the ERLANG-LOOP module (it starts the model-checking computation)
***)

fmod COMMAND-GRAMMAR is
	protecting PARSING-SYNTAX .

	*** The commands that may be issued to the system are terms of sort Command.
	sort Command .

	*** The add-module directive includes the function definitions from
	*** the Core-Erlang module that is given as an argument.
	*** Note: Use the (Core-Erlang) output of the Erlang compiler; the "maudify"
	***       tool automatically clears up the syntax. Additionally one has to
	***       put brackets around the function definitions within the Core-Erlang
	***	  source-code.
	op add-module : Program Atom Args -> Command [ctor] .

  op fwd-step : -> Command [ctor] .

  op pprint-sys : -> Command [ctor] .
endfm

mod FORWARD-EXPLORATION is
  protecting META-LEVEL .
	protecting SEM_SYSTEM .

  op #computeFwdSteps : Sys -> Sys [frozen] .

  var RES : ResultPair .
  var SYS : Sys .

  eq #computeFwdSteps(SYS) = #downSystem(getTerm(metaRewrite(['THEORY], #up(SYS), 1))) .

endm

mod ERLANG-LOOP is
	protecting QID .
	protecting META-LEVEL .
	including LOOP-MODE .
	protecting PARSING-SYNTAX-DOWN .
	protecting PRINT-SYNTAX-ERROR .
	protecting MAUDE-SYNTAX-UP .
  protecting SEM_SYSTEM .
  protecting FORWARD-EXPLORATION .
  protecting PRETTY_PRINT .
  protecting SEM_TRANSITIONS .

	*** This system module is a simple interface to Maude's LOOP-MODE module.
	*** We use LOOP-MODE as the input/output facility. If a command according
	*** to the command grammar above is input in parenthesis (s.t. it is recognized
	*** as input to the loop), we execute the corresponding actions by rewriting.

	*** To distinguish different phases during command execution: We accept input
	*** in the idle phase. After parsing the quoted identifiers that were input,
	*** we end up in the parsed or error phase.
	sort Phase .
	op idle : -> Phase .
	op parsed : -> Phase .
	op error : -> Phase .

	sort ParseResult .
	subsort Term < ParseResult .
	op #no-parse : -> ParseResult .


  op init : -> System .
	eq init = [nil, < idle, #no-parse, #empty-system >, nil] .

	*** the state-component of the loop-mode tuple
	op <_,_,_> : Phase ParseResult Sys -> State [frozen] .

	vars QIL QIL' : QidList .
	vars T T1 T2 T3 : Term .
	var Result : ResultPair? .
  var SYS : Sys .

	crl [in] : [QIL, < idle, #no-parse, SYS >, QIL']
		=> if Result :: ResultPair
		   then
			[nil, < parsed, getTerm(Result), SYS >, 'command 'parsed 'complete]
		   else
			[nil, < error, #no-parse, SYS >, printSyntaxError(Result, QIL)]
		   fi
	    if QIL =/= nil /\
	       Result := metaParse(GRAMMAR, QIL, 'Command) .

	rl [add-module] : [nil, < parsed, 'add-module[T1,T2,T3], SYS >, QIL']
		=> [nil, < idle, #no-parse, #setup-first-proc(SYS, #downExp(T2), #downFunDefSeq(T1), #downExpSeq(T3)) >, QIL' 'module 'included '.] .

  crl [fwd-step] : [nil, < parsed, 'fwd-step.Command, SYS >, QIL' ]
     => [nil, < idle, 'pprint-sys.Command, (#computeFwdSteps(SYS)) >, QIL' ]
     if SYS =/= #computeFwdSteps(SYS) .

  rl [pprint-sys] : [nil, < idle, 'pprint-sys.Command, SYS >, QIL' ] =>
   [nil, <  parsed, 'fwd-step.Command, SYS >, QIL' #pretty-print-sys(SYS) ] .

  rl [pprint-sys] : [nil, < parsed, 'pprint-sys.Command, SYS >, QIL' ] =>
   [nil, <  parsed, 'fwd-step.Command, SYS >, QIL' ] .
endm
