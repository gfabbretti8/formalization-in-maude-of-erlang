\documentclass{article}[12pt,a4paper]

\input{macros}

\usepackage{listings}
\usepackage[version=3]{mhchem} % Package for chemical equation typesetting
\usepackage{siunitx} % Provides the \SI{}{} and \si{} command for typesetting SI
\usepackage{algorithm}
\usepackage{algpseudocode}
% units
\usepackage{fancyvrb}
\usepackage{hyperref}
\usepackage{breakurl}             % Not needed if you use pdflatex only.
\usepackage{underscore}           % Only needed if you use pdflatex.
\usepackage{microtype}%if unwanted, comment out or use option "draft"
\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{rotating}
\usepackage{todonotes}
\usepackage{mathpartir}
\usepackage{url}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{float}
\usepackage{hyperref}
\usepackage{thm-restate}
\usetikzlibrary{matrix}

\renewcommand{\labelenumi}{\alph{enumi}.} % Make numbering in the enumerate environment by letter rather than number (e.g. section 6)

\theoremstyle{definition}
\newtheorem{example}{Example}[section]
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newcommand{\paral}{\;|\;}
\newcommand{\cons}{\mbox{:}}

\usetikzlibrary{calc,decorations.pathmorphing,shapes}
\newcounter{sarrow}
\newcommand\blts[1]{%
  \stepcounter{sarrow}%
  \mathrel{\begin{tikzpicture}[baseline= {( $ (current bounding box.south) + (0,-0.5ex) $ )}]
      \node[inner sep=.5ex] (\thesarrow) {$\scriptstyle #1$};
      \path[draw,<-,decorate,
      decoration={zigzag,amplitude=1.2pt,segment length=1.5mm,pre=lineto,pre length=6pt}]
      (\thesarrow.south east) -- (\thesarrow.south west);
    \end{tikzpicture}}%
}
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}


\begin{document}

\section{Consistency}

\begin{tikzpicture}
  \matrix (m) [matrix of math nodes,row sep=3em,column sep=4em,minimum width=2em]
  {
    \text{S} & \text{R-S} \\
    \text{I} & \text{R-I} \\};
  \path[-stealth]
  (m-1-1) edge node [left] {$gen(S)$} (m-2-1)
  edge node [below] {$\mathcal{B}_t$} (m-1-2)
  (m-2-1.east|-m-2-2) edge node [below] {$\text{CONCUR}$}
  node [] {} (m-2-2)
  (m-1-2) edge node [right] {$gen(R-S)$} (m-2-2);
\end{tikzpicture}


Rules have the following shape:
\[r: t\rightarrow t'~\text{if}~\overline{eq}_n\]
where $\overline{eq}_n$ is a sequence of equational conditions that we use to
define which transitions are possible and which are not.

Rules are defined by using variables so that with a finite amount of rules we
can capture infinite possible scenarios.

Now we proceed to show how concrete instances can be generated starting from the
schemas. First some notation.

\begin{definition}[Ground Terms]
  For a given signature $\Sigma=\langle Sorts, Operations \rangle$ the set of ground
  terms $T_\Sigma$ is inductively defined as follows:
  \begin{enumerate}
  \item All constants of sorts S in Operations are ground terms of sort S.
  \item For every function symbol $f:S_1,\ldots,S_n\rightarrow S$ in Operations,
    if $t_1,\ldots,t_n$ are ground terms of sorts $S_1,\ldots,S_n$,
    respectively, then $f(t_1,\ldots,t_n)$ is a ground term of sort $S$ where
    $S_1,\ldots,S_n\in Sorts$
  \end{enumerate}

  With $T_\Sigma^n$ we indicate all the ground terms up to the $n$-nth iteration
  of the inductive definition. For example, $T_\Sigma^0$ is the set of constant
  symbols, $T_\Sigma^1$ is the set of ground terms given by all the possible
  applications of the operators to $T_\Sigma^0$, and so on.\\
  With $T_{\Sigma, S}^n$ we indicate the ground terms of sort $S$ up to the
  $n$-nth iteration.
\end{definition}

\begin{algorithm}
  \caption{getInstances($\Sigma,r,E,n$)}\label{alg:cap}
  \begin{algorithmic}
    \State $\langle Sorts, Operators \rangle \gets \Sigma$
    \State $V \gets vars(r)$    \Comment{Get vars used by the rule}
    \State $S = \{\{v\} \times T_{\Sigma,type(v)}^n | v \in V\}$ 
    \State $ConcInst = S_{v_1} \times \ldots \times S_{v_m}$
    \State $ConcRules \gets \emptyset$ 
    \ForEach{$i \in ConcInst$}
    \State $CR \gets instantiate(i,r)$
    \State $t' \rightarrow t'~\text{if}~\overline{eq}_l \gets CR$
    \If{$E\vdash \overline{eq}_l$}
    \State $ConcRules \gets ConcRules \cup \{t \rightarrow t'\}$
    \EndIf
    \EndFor\\
    \Return $ConcRules \cup getInstances(\Sigma,r,E,n+1)$
  \end{algorithmic}
\end{algorithm}

\end{document}