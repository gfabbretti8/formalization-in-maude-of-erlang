***(

	LABEL.MAUDE

	The whole system comprises two levels:
	The equational theory that evaluates expressions inside of the process's context and
	the rewriting rules that model inter-process communication (message passing, exit signals, etc.)
	Labels are used to abstract the current state. In case of
	  (a) the equational theory, the process's label indicates by
	        - the label tau, that the normalisation within the equational theory is continued
	        - any other label indicates a normal form w.r.t. the equational theory. The
	          label then gives more details why normalisation stopped.
	      These labels are defined in the functional module SEM_LABEL.

	  (b) the rewriting rules of the transition level operate on equivalence classes w.r.t.
	      the underlying equational theory. They non-deterministically select one of the
	      (normalised) processes and model the behaviour of the side-effect according to
	      its description in the process's label.
	      Which process was picked and the side-effect that took place is reflected by the
	      second kind of labels: System level labels.
	      They are defined in the second functional module SEM_SYSLABEL .

***)

mod SEM_LABEL is
	protecting SYNTAX .
	protecting SEM_PID .
	protecting MAUDE-SYNTAX-UPDOWN .

	*** We distinguish between two types of expression level labels.
	*** First we have labels that signal a side-effect change of the whole system state.
	*** They indicate that a normal form w.r.t. the equational theory is reached.
	sort Label .
	sort StopLabel .

  subsort StopLabel < Label .

  var ARGS : Args .

  op empty : -> Label [ctor] .

	*** An expression label "tau" is an "unobservable" action.
	*** This means that the process normalisation within the equational theory continues.
	op tau : -> Label [ctor] .

	*** The send expression-level label is used to signal that the corresponding process
	*** sends a message. The first argument is the receiving PID, the second argument the
	*** constant sent.
	*** Because sending messages to another process is a side-effect, this label indicates
	*** a normal form w.r.t. the equational theory.
	op _!_ : Pid GroundValues -> StopLabel [ctor] .

	*** To model the reception on the system level, we switch to the "receive"
	*** expression level label as soon as we find a matching message in the process's mailbox.
	op receive_ : ClauseSeq -> StopLabel [ctor] .

	*** When evaluating a receive-statement without a matching message in the mailbox,
	*** we distinguish two cases:
	*** First, there is no timeout specified. In this case, we indicate the temporary end
	*** of the normalisation by setting the process label to "blocked".
	*** If there is a timeout specified, we indicate the waiting condition. On the system level,
	*** this means a non-deterministic choice: We do not have a notion of time. Therefore one
	*** can always continue waiting for arrival of a message or one can issue a timeout.
	op blocked : -> StopLabel [ctor] .

	op spawn(_,_) : Atom Args -> StopLabel [ctor] .

  op crashed : -> StopLabel [ctor] .
	*******************************
  *** METAREPRESENTATION PART ***
	*******************************

	op #up : Label -> Term [memo] .
	op #downLabel : Term -> Label [memo] .

	var EX : Exp .
	var PID : Pid .
	var ATOM : Atom .
	vars T T1 T2 T3 : Term .
	vars A1 A2 : Atom .
  var CLSEQ : ClauseSeq .

	*** Implementation of the meta-representation part
	eq #up(empty) = 'empty.Label .
	eq #up(tau) = 'tau.Label .
	eq #up(PID ! EX) = '_!_[#up(PID),#up(EX)] .
	eq #up(receive(CLSEQ)) = 'receive_[#up(CLSEQ)] .
	eq #up(blocked) = 'blocked.StopLabel .
  eq #up(crashed) = 'crashed.StopLabel .
  eq #up(spawn(ATOM, ARGS)) = 'spawn`(_`,_`)[#up(ATOM),#up(ARGS)] .

	*** Lowering the meta-representation level of expression level labels
	eq #downLabel('empty.Label) = empty .
	eq #downLabel('tau.Label) = tau .
	eq #downLabel('_!_[T1, T2]) = #downPid(T1) ! #downExp(T2) .
	eq #downLabel('receive_[T]) = receive #downClauseSeq(T) .
	eq #downLabel('blocked.StopLabel) = blocked .
  eq #downLabel('crashed.StopLabel) = crashed .
	eq #downLabel('spawn`(_`,_`)[T1,T2]) = spawn(#downAtom(T1), #downExpSeq(T2)) .
endm

