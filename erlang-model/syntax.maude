fmod SYNTAX-COMMON is

  sort Program .
  subsort Construct < Program .

  sort Construct .

  sort Exp ExpSeq .
  subsort Exp < Construct .
  subsort Exp < ExpSeq .
  op #empty : -> ExpSeq .
  op #empty : -> Exp .
  op #hole : -> Exp .
  op #bottom : -> Exp .
  op #crashed : -> Exp .
  op _,_ : ExpSeq ExpSeq -> ExpSeq [ctor assoc prec 60 gather (e E) format (o m! o o)] .

  sorts List Nil .
  subsort Nil < List .
  subsort List < Exp .

  op [] : -> Nil [ctor].
  op [_] : Pattern -> List [ctor prec 0 gather (&) format (m! o m! o)].
  op [_|_] : Pattern Pattern -> List [ctor prec 0 gather (& &) format (m! o m! o m! o)] .

  sort Atom .
  sort ErlInt .

  sort Var .
  subsort Var < Exp .

  sort GroundValues .
  subsorts List Atom ErlInt < GroundValues .

  sort Pattern .
  subsorts GroundValues Var < Pattern .
  subsort Pattern < Exp .

  sort Match .
  subsort Match < Exp .
  op _=_ : Pattern Exp -> Match [ctor prec 55 format (o o m! o)] .

  sort Clause .
  sort ClauseSeq .
  subsort Clause < ClauseSeq .

  op _->_ : Exp Exp -> Clause [ctor prec 40 format (o m! o o)] .
  op _;_ : ClauseSeq ClauseSeq -> ClauseSeq [ctor assoc prec 45 format (o o m! o)].

  sorts If IfClause IfClauseSeq .
  subsort IfClause < Clause .
  subsort IfClause < IfClauseSeq .
  subsort IfClauseSeq < ClauseSeq .
  subsort If < Exp .

  op if_end : ClauseSeq -> If [ctor prec 50 format (m! o m! o)] .

  sorts FunDef FunName FunDefSeq FunCall .
  subsort FunDef < Construct .
  subsort Atom < FunName .
  subsort FunDef < FunDefSeq .
  subsort FunCall < Exp .

  op fun_()->_. : FunName ExpSeq -> FunDef [ctor prec 70 gather(e e) format (m! o m! m! m! o m! o)] .
  op __ : FunDefSeq FunDefSeq -> FunDefSeq [ctor assoc prec 71 format(o o o)] .
  op _() : Exp -> FunCall [ctor prec 50 format (o m! m! o)] .
  op _(_) : Exp Exp -> FunCall [ctor prec 50 gather (E e) format (o m! o m! o)] .
  op _:_(_) : Exp Exp Exp -> FunCall [ctor prec 50 gather (E E e) format (o o m! m! o m! o )] .

  sort Send .
  subsort Send < Exp .

  op _!_ : Exp Exp -> Send [ctor prec 35 format (o m! o o)] .

  sort Receive ReceiveClause ReceiveClauseSeq .
  subsort Receive < Exp .
  subsort ReceiveClause < Clause .
  subsort ReceiveClauseSeq < ClauseSeq .

  op receive_end : ClauseSeq -> Receive [ctor prec 35 format (m! o m! o)].

endfm

fmod SYNTAX is
	extending SYNTAX-COMMON .
	protecting STRING .
	protecting INT .

  op var : String -> Var [ctor format (b o)] .
	op atom : String -> Atom [ctor format (b o)] .
	op int : Int -> ErlInt [ctor format (b o)] .

endfm

fmod PARSING-SYNTAX is
	protecting META-LEVEL .
	extending SYNTAX .
	sort Token .

	subsort Token < Atom ErlInt Var .

	sort NeTokenList .
	subsort Token < NeTokenList .
  subsort NeTokenList < Exp .
	op _,_ : NeTokenList NeTokenList -> NeTokenList [ctor assoc prec 65 gather (E e) format (o m! o o)] .

	sort ListToken .
	subsort ListToken < GroundValues .
  subsort List < ListToken .

endfm

------------------------------------------------------------------------------------------

--- INTERNAL-SYNTAX

------------------------------------------------------------------------------------------

fmod MAUDE-SYNTAX-UP is
	protecting SYNTAX .
	protecting META-LEVEL .
	protecting META-UP-DOWN .

	*******************************
  *** METAREPRESENTATION PART ***
	*******************************

	var STR : String .
	var INT : Int .
	var CHR : Char .

	op #up : Atom -> Term [memo] .
	op #up : Var -> Term [memo] .
	op #up : ErlInt -> Term [memo] .

	eq #up(var(STR)) = 'var[#up(STR)] .
	eq #up(atom(STR)) = 'atom[#up(STR)] .
	eq #up(int(INT)) = 'int[#up(INT)] .
	eq #up([]) = '`[`].Nil .

	var ATOM : Atom .
  var FNAME : FunName .
  var PAT : Pattern .
	vars EX EX1 EX2 EX3 : Exp .
  var EXSEQ EXSEQ' : ExpSeq .
  vars CLS CLS1 CLS2 : ClauseSeq .

	op #up : ExpSeq -> Term [memo] .
	eq #up(EXSEQ, EXSEQ') = '_`,_[#up(EXSEQ), #up(EXSEQ')] .

  op #up : Exp -> Term [memo] .
  eq #up(#empty) = '#empty.ExpSeq .
  eq #up(#hole) = '#hole.ExpSeq .
  eq #up(#crashed) = '#crashed.ExpSeq .
  eq #up(#bottom) = '#bottom.ExpSeq .

  op #up : FunDef -> Term [memo] .
  eq #up(fun FNAME ()-> EXSEQ .) = 'fun_`(`)->_[#up(FNAME), #up(EXSEQ)] .

  op #up : IfClause -> Term [memo] .
  eq #up(if CLS end) = 'if_end[#up(CLS)] .

  op #up : List -> Term [memo] .
  eq #up([EX]) = '`[_`][#up(EX)] .
  eq #up([EX1 | EX2]) = '`[_|_`][#up(EX1), #up(EX2)] .

  op #up : Pattern -> Term [memo] .

  op #up : Clause -> Term [memo] .
  eq #up(EX1 -> EX2) = '_->_[#up(EX1), #up(EX2)] .

  op #up : ClauseSeq -> Term [memo] .
  eq #up(CLS1 ; CLS2) = '_;_[#up(CLS1), #up(CLS2)] .

	*** all the terms with outermost operator symbol _,_ __ or _=_

  vars FUNDEFSEQ1 FUNDEFSEQ2 : FunDefSeq .

  op #up : FunDefSeq -> Term [memo] .
  eq #up(FUNDEFSEQ1 FUNDEFSEQ2) = '_`,_[#up(FUNDEFSEQ1), #up(FUNDEFSEQ2)] .

  op #up : Match -> Term [memo] .
  eq #up(PAT = EX) = '_=_[#up(PAT), #up(EX)] .

  op #up : FunCall -> Term [memo] .
  eq #up(EX()) = '_`(`)[#up(EX)] .
  eq #up(_`(_`)(EX1, EX2)) = '_`(_`)[#up(EX1), #up(EX2)] .
  eq #up(EX1 : EX2 (EX3)) = '_:_`(_`)[#up(EX1), #up(EX2), #up(EX3)] .

  op #up : Send -> Term [memo] .
  eq #up(EX1 ! EX2) = '_!_[#up(EX1), #up(EX2)] .
  eq #up(receive CLS end) = 'receive_end[#up(CLS)] .

endfm
