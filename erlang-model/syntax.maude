fmod LANGUAGE-CONSTRUCT is
  sort Construct .
endfm

fmod GENERIC-EXP-SYNTAX is
  protecting LANGUAGE-CONSTRUCT .

  sort Exp .
  subsort Exp < Construct .
  op _,_ : Exp Exp -> Exp [ctor assoc prec 60 gather (E e) format (o m! o o)] .

endfm


fmod LIST-SYNTAX is
  including GENERIC-EXP-SYNTAX .

  sorts List Nil .
  op [] : -> Nil .

  subsort Nil < List .

  op [_] : Exp -> List [ctor prec 0 gather (&) format (m! o m! o)].
  op [_|_] : Exp Exp -> List [ctor prec 0 gather (& &) format (m! o m! o m! o)] .

  subsort List < Exp .

endfm

fmod LITERAL-SYNTAX is
  protecting LIST-SYNTAX .
  including GENERIC-EXP-SYNTAX .

  sort Atom .
  sort ErlInt .

  sort Literal .

  subsort Literal < Exp .
  subsorts Atom ErlInt List < Literal .
endfm


fmod PATTERN-SYNTAX is
  including LANGUAGE-CONSTRUCT .
  including LITERAL-SYNTAX .
  including LIST-SYNTAX .

  sort Pattern .
  subsort Pattern < Construct .
  subsort List < Pattern .
  subsort Literal < Pattern .

  subsort Pattern < Exp .
endfm

fmod CLAUSE-SYNTAX is
  protecting LANGUAGE-CONSTRUCT .
  protecting GENERIC-EXP-SYNTAX .

  sort Clause .

  op _->_ : Exp Exp -> Clause [ctor prec 40 format (o m! o o)] .

  sort ClauseSeq .
  subsort Clause < ClauseSeq .
  op _;_ : ClauseSeq ClauseSeq -> ClauseSeq [ctor assoc prec 45 format (o o m! o)].
endfm

fmod IF-THEN-ELSE-SYNTAX is
  protecting GENERIC-EXP-SYNTAX .
  protecting CLAUSE-SYNTAX .

  sort If .
  op if_end : ClauseSeq -> If [ctor prec 50 format (m! o m! o)] .

  sorts IfClause IfClauseSeq .
  subsort IfClause < Clause .
  subsort IfClause < IfClauseSeq .
  subsort IfClauseSeq < ClauseSeq .

  subsort If < Exp .
endfm

fmod FUNCTION-SYNTAX is
  protecting LITERAL-SYNTAX .
  protecting GENERIC-EXP-SYNTAX .

  sort FunDef .
  sort FunName .
  subsort FunDef < Construct .
  subsort Atom < FunName .

  op fun_()->_. : FunName Exp -> FunDef [ctor prec 70 gather(e e) format (m! o m! m! m! o m! o)] .

  sort FunDefSeq .
  subsort FunDef < FunDefSeq .
  op __ : FunDefSeq FunDefSeq -> FunDefSeq [ctor assoc prec 71 format(o o o)] .

  sort FunCall .

  op _() : Exp -> FunCall [ctor prec 50 format (o m! m! o)] .

  op _(_) : Exp Exp -> FunCall [ctor prec 50 gather (E e) format (o m! o m! o)] .

  op _:_(_) : Exp Exp Exp -> FunCall [ctor prec 50 gather (E E e) format (o o m! m! o m! o )] .

  subsort FunCall < Exp .

endfm


fmod SEND-SYNTAX is
  protecting GENERIC-EXP-SYNTAX .

  sort Send .
  subsort Send < Exp .

  op _!_ : Exp Exp -> Send [ctor prec 50 gather (E e) format (o m! o o)] .

endfm

fmod RECEIVE-SYNTAX is
  protecting GENERIC-EXP-SYNTAX .
  protecting LANGUAGE-CONSTRUCT .
  protecting PATTERN-SYNTAX .
  protecting CLAUSE-SYNTAX .

  sort Receive .
  subsort Receive < Exp .

  sort ReceiveClause .
  subsort ReceiveClause < Clause .

  sort ReceiveClauseSeq .
  subsort ReceiveClauseSeq < ClauseSeq .

  op receive_end : ClauseSeq -> Receive [ctor prec 50 format (m! o m! o)].

endfm


fmod SYNTAX-COMMON is
	protecting STRING .
	protecting INT .
	protecting FLOAT .
  protecting GENERIC-EXP-SYNTAX .
  protecting LIST-SYNTAX .
  protecting LITERAL-SYNTAX .
  protecting PATTERN-SYNTAX .
  protecting CLAUSE-SYNTAX .
  protecting IF-THEN-ELSE-SYNTAX .
  protecting FUNCTION-SYNTAX .
  protecting SEND-SYNTAX .
  protecting RECEIVE-SYNTAX .

  sort Program .
  subsort Construct < Program .

endfm

fmod SYNTAX is
	extending SYNTAX-COMMON .
	protecting STRING .
	protecting INT .

	op atom : String -> Atom [ctor format (b o)] .
	op int : Int -> ErlInt [ctor format (b o)] .

endfm

fmod PARSING-SYNTAX is
	protecting META-LEVEL .
	extending SYNTAX .
  extending LITERAL-SYNTAX .
	sort Token .

	subsort Token < Atom ErlInt .

	sort NeTokenList .
	subsort Token < NeTokenList .
  subsort NeTokenList < Exp .
	op _,_ : NeTokenList NeTokenList -> NeTokenList [ctor assoc prec 65 gather (E e) format (o m! o o)] .

	sort ListToken .
	subsort ListToken < Literal .
  subsort List < ListToken .

endfm


fmod MAUDE-SYNTAX-UP is
	protecting SYNTAX .
	protecting META-LEVEL .
	protecting META-UP-DOWN .

	*******************************
  *** METAREPRESENTATION PART ***
	*******************************

	op #up : Exp -> Term [memo] .

  op #up : List -> Term [memo] .

  op #up : Clause -> Term [memo] .
  op #up : ClauseSeq -> Term [memo] .

  op #up : Pattern -> Term [memo] .

  op #up : Send -> Term [memo] .

  op #up : FunName -> Term [memo] .
  op #up : FunDef -> Term [memo] .
  op #up : FunDefSeq -> Term [memo] .

	var STR : String .
	var INT : Int .
	var CHR : Char .

	eq #up(atom(STR)) = 'atom[#up(STR)] .
	eq #up(int(INT)) = 'int[#up(INT)] .
	eq #up([]) = '`[`].Nil .

	var ATOM : Atom .
  var FNAME : FunName .
	vars EX EX1 EX2 EX3 : Exp .
  vars CLS CLS1 CLS2 : ClauseSeq .

  eq #up(fun FNAME ()-> EX .) = 'fun_`(`)->_[#up(FNAME), #up(EX)] .
  eq #up(if CLS end) = 'if_end[#up(CLS)] .
  eq #up([EX]) = '`[_`][#up(EX)] .
  eq #up([EX1 | EX2]) = '`[_|_`][#up(EX1), #up(EX2)] .
  eq #up(EX1 -> EX2) = '_->_[#up(EX1), #up(EX2)] .
  eq #up(CLS1 ; CLS2) = '_;_[#up(CLS1), #up(CLS2)] .
	eq #up(EX1, EX2) = '_`,_[#up(EX1), #up(EX2)] .


	*** all the terms with outermost operator symbol _,_ or __

  vars FUNDEFSEQ1 FUNDEFSEQ2 : FunDefSeq .

  eq #up(FUNDEFSEQ1 FUNDEFSEQ2) = '_`,_[#up(FUNDEFSEQ1), #up(FUNDEFSEQ2)] .
  eq #up(EX()) = '_`(`)[#up(EX)] .
  eq #up(_`(_`)(EX1, EX2)) = '_`(_`)[#up(EX1), #up(EX2)] .
  eq #up(EX1 : EX2 (EX3)) = '_:_`(_`)[#up(EX1), #up(EX2), #up(EX3)] .
  eq #up(EX1 ! EX2) = '_!_[#up(EX1), #up(EX2)] .
  eq #up(receive CLS end) = 'receive_end[#up(CLS)] .

endfm






