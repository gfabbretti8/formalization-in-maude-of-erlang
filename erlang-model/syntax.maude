fmod SYNTAX-COMMON is

  sort Program .
  subsort Construct < Program .

  sort Construct .

  sort Exp .
  subsort Exp < Construct .
  op _,_ : Exp Exp -> Exp [ctor assoc prec 60 gather (E e) format (o m! o o)] .

  sorts List Nil .
  subsort Nil < List .
  subsort List < Exp .

  op [] : -> Nil [ctor].
  op [_] : Exp -> List [ctor prec 0 gather (&) format (m! o m! o)].
  op [_|_] : Exp Exp -> List [ctor prec 0 gather (& &) format (m! o m! o m! o)] .

  sort Atom .
  sort ErlInt .
  sort Literal .

  subsort Literal < Exp .
  subsorts Atom ErlInt List < Literal .

  sort Pattern .
  subsort Pattern < Construct .
  subsorts List Literal < Pattern .
  subsort Pattern < Exp .

  sort Clause .
  sort ClauseSeq .
  subsort Clause < ClauseSeq .

  op _->_ : Exp Exp -> Clause [ctor prec 40 format (o m! o o)] .
  op _;_ : ClauseSeq ClauseSeq -> ClauseSeq [ctor assoc prec 45 format (o o m! o)].

  sorts If IfClause IfClauseSeq .
  subsort IfClause < Clause .
  subsort IfClause < IfClauseSeq .
  subsort IfClauseSeq < ClauseSeq .
  subsort If < Exp .

  op if_end : ClauseSeq -> If [ctor prec 50 format (m! o m! o)] .

  sorts FunDef FunName FunDefSeq FunCall .
  subsort FunDef < Construct .
  subsort Atom < FunName .
  subsort FunDef < FunDefSeq .
  subsort FunCall < Exp .

  op fun_()->_. : FunName Exp -> FunDef [ctor prec 70 gather(e e) format (m! o m! m! m! o m! o)] .
  op __ : FunDefSeq FunDefSeq -> FunDefSeq [ctor assoc prec 71 format(o o o)] .
  op _() : Exp -> FunCall [ctor prec 50 format (o m! m! o)] .
  op _(_) : Exp Exp -> FunCall [ctor prec 50 gather (E e) format (o m! o m! o)] .
  op _:_(_) : Exp Exp Exp -> FunCall [ctor prec 50 gather (E E e) format (o o m! m! o m! o )] .

  sort Send .
  subsort Send < Exp .

  op _!_ : Exp Exp -> Send [ctor prec 50 gather (E e) format (o m! o o)] .


  sort Receive ReceiveClause ReceiveClauseSeq .
  subsort Receive < Exp .
  subsort ReceiveClause < Clause .
  subsort ReceiveClauseSeq < ClauseSeq .

  op receive_end : ClauseSeq -> Receive [ctor prec 50 format (m! o m! o)].

endfm

fmod SYNTAX is
	extending SYNTAX-COMMON .
	protecting STRING .
	protecting INT .

	op atom : String -> Atom [ctor format (b o)] .
	op int : Int -> ErlInt [ctor format (b o)] .

endfm

fmod PARSING-SYNTAX is
	protecting META-LEVEL .
	extending SYNTAX .
	sort Token .

	subsort Token < Atom ErlInt .

	sort NeTokenList .
	subsort Token < NeTokenList .
  subsort NeTokenList < Exp .
	op _,_ : NeTokenList NeTokenList -> NeTokenList [ctor assoc prec 65 gather (E e) format (o m! o o)] .

	sort ListToken .
	subsort ListToken < Literal .
  subsort List < ListToken .

endfm


fmod MAUDE-SYNTAX-UP is
	protecting SYNTAX .
	protecting META-LEVEL .
	protecting META-UP-DOWN .

	*******************************
  *** METAREPRESENTATION PART ***
	*******************************

  op #up : Pattern -> Term [memo] .

	var STR : String .
	var INT : Int .
	var CHR : Char .

	eq #up(atom(STR)) = 'atom[#up(STR)] .
	eq #up(int(INT)) = 'int[#up(INT)] .
	eq #up([]) = '`[`].Nil .

	var ATOM : Atom .
  var FNAME : FunName .
	vars EX EX1 EX2 EX3 : Exp .
  vars CLS CLS1 CLS2 : ClauseSeq .

	op #up : Exp -> Term [memo] .
	eq #up(EX1, EX2) = '_`,_[#up(EX1), #up(EX2)] .

  op #up : FunDef -> Term [memo] .
  eq #up(fun FNAME ()-> EX .) = 'fun_`(`)->_[#up(FNAME), #up(EX)] .

  op #up : IfClause -> Term [memo] .
  eq #up(if CLS end) = 'if_end[#up(CLS)] .

  op #up : List -> Term [memo] .
  eq #up([EX]) = '`[_`][#up(EX)] .
  eq #up([EX1 | EX2]) = '`[_|_`][#up(EX1), #up(EX2)] .

  op #up : Clause -> Term [memo] .
  eq #up(EX1 -> EX2) = '_->_[#up(EX1), #up(EX2)] .

  op #up : ClauseSeq -> Term [memo] .
  eq #up(CLS1 ; CLS2) = '_;_[#up(CLS1), #up(CLS2)] .

	*** all the terms with outermost operator symbol _,_ or __

  vars FUNDEFSEQ1 FUNDEFSEQ2 : FunDefSeq .

  op #up : FunDefSeq -> Term [memo] .
  eq #up(FUNDEFSEQ1 FUNDEFSEQ2) = '_`,_[#up(FUNDEFSEQ1), #up(FUNDEFSEQ2)] .

  op #up : FunCall -> Term [memo] .
  eq #up(EX()) = '_`(`)[#up(EX)] .
  eq #up(_`(_`)(EX1, EX2)) = '_`(_`)[#up(EX1), #up(EX2)] .
  eq #up(EX1 : EX2 (EX3)) = '_:_`(_`)[#up(EX1), #up(EX2), #up(EX3)] .

  op #up : Send -> Term [memo] .
  eq #up(EX1 ! EX2) = '_!_[#up(EX1), #up(EX2)] .
  eq #up(receive CLS end) = 'receive_end[#up(CLS)] .

endfm
