***(

	MATCHING.MAUDE

	In this file we implement the pattern matching code. Both Maude modules
	that are defined here are functional modules. This is important as they
	are used within the conditions of the equations of the underlying
	equational theory.

	First, ordinary pattern matching is specified in the SEM_MATCH functional
	module. The #match operation takes a pattern and a constant and tries to
	match the pattern against the constant.
	
	Second, the SEM_MATCH_ENTITY functional module defines the more subtle
	operations needed to match the clauses of a receive statement against
	the contents of a entity.
	The reception of messages is more complicated as it uses two levels
	of recursion: The clauses are recursively matched against the first
	message in the entity; if there is no match, the clause list is
	again matched against the remaining messages. The recursion terminates
	when the first match is found or every message of the entity has failed
	to match any clause.
	As the clauses may contain guards (additional conditions that control 
	if the clause may be evaluated in case of a matching pattern), we need the
	equational theory to evaluate the guard expressions. Note however,
	that according to the Core-Erlang semantics, there must not occur any 
	system level transitions during the evaluation of a guard (i.e. no send
	or receive statements, etc). Therefore the equational theory suffices
	and we never have to switch to the rewriting rules of the system level.

***)

mod SEM_MATCH is
	protecting SYNTAX .


	*** As most of the pattern matching operations are partial functions
	*** because of possible matching failures, we declare an error supersort of Env:
  sort Env .
  op #not-empty-env : -> Env [ctor] .
	op #empty-env : -> Env [ctor] .
	op _,_ : Env Env -> Env [ctor assoc comm id: #empty-env prec 60] .
	sort Env? .
	subsort Env < Env? .

	*** The #nomatch constructor indicates the failure of a matching
	*** operation. If it is included in a variable environment and since
	*** it is not of sort Env, the resulting term is of kind [Env?].
	*** In this way, we distinguish between successful and unsuccessful
	*** matching operations.
	op #nomatch : -> Env? [ctor] .

	*** The #match operation tries to match the given pattern with the
	*** constant provided as second argument. Because there may be many
	*** variables that have to be bound to unify the two terms, the
	*** result term is of sort Env (and not just a single Binding).
	op #match : Pattern Literal ~> Env .


	var LIT : Literal .
	var PATSEQ : Pattern .
	vars PAT PAT1 PAT2 : Pattern .
	vars L L1 L2 : Literal .


	*** The second case: Two identical terms are unified (without the need to
	*** bind any variables)
	*** Note: The cases of matching two empty lists [] or two 0-ary tuples {}
	***       are implicitly covered here, too.
	eq #match(LIT, LIT) = #not-empty-env .

	*** A pattern may be a list. Therefore we match a list of patterns
	*** against a list of constants by pairwise matching the list elements.
	eq #match([PAT1 | PAT2], [L1 | L2]) = #match(PAT1, L1), #match(PAT2, L2) .


	*** All other cases lead to an incorrect matching.
	eq #match(PAT, LIT) = #nomatch [owise] .

endm

mod SEM_MATCH_ENTITY is
	extending SYNTAX .
	protecting SEM_MATCH .
  protecting SEM_ENTITIES .

	sort ClauseMatchResult .

  op #empty-clauselist : -> ClauseSeq [ctor] .

	op #entityMatch(_|_) : ClauseSeq Message -> ClauseMatchResult .

	op #entityMatch(_|_|_) : ClauseSeq ClauseSeq Message -> ClauseMatchResult .

	op #entityMatchSuccess(_|_) : Exp Message -> ClauseMatchResult [ctor] .

	op #entityMatchFailure : -> ClauseMatchResult [ctor] .

  var MSG : Message .
	var CLAUSE : Clause .
	var NECLLIST : ClauseSeq .
	vars CLAUSES CLAUSES1 : ClauseSeq .
	var PAT : Pattern .
	vars EX EX1 : Exp .
  var E : Entity .
	vars ENTS ENTS1 ENTS2 : Entities .
	vars ENV : Env .
	var GUARD : Exp .
  vars P P' : Pid .
  var ASET : AttributeSet .
  var LIT : Atom .

	eq #entityMatch(CLAUSES | MSG) = #entityMatch(CLAUSES | CLAUSES | MSG) .

	ceq #entityMatch(CLAUSES | CLAUSE ; CLAUSES1 | < payload: LIT, ASET >) =
      #entityMatch(CLAUSES | CLAUSES1 | < payload: LIT, ASET >)
		if (PAT -> EX) := CLAUSE
		/\ not(#match(PAT, LIT) :: Env) .

	ceq #entityMatch(CLAUSES | CLAUSE ; CLAUSES1 | < payload: LIT, ASET >) =
	    #entityMatchSuccess(EX | < payload: LIT, ASET >)
		if (PAT  -> EX) := CLAUSE
		/\ ENV := #match(PAT, LIT) .

	eq #entityMatch(CLAUSES | #empty-clauselist | MSG ) = #entityMatchFailure .

endm
