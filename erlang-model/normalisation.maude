mod SEM_NORMALISATION is
	protecting SYNTAX .
  protecting HELP-SYNTAX .
  protecting SEM_ENTITIES .

	var EX : Exp .
  var EXSEQ : ExpSeq .
	var INT : Int .
	var P' : ErlInt .
  var CL : Clause .
  var CLSEQ : ClauseSeq .
  var P : Pid .
  var EL : Label .
  var ME : ModEnv .
  var ASET ASET' : AttributeSet .
  var GVALUE : GroundValues .
  vars STORE STORE' : Store .
  var VAR : Var .

  *** Case 1: the if clause has evaluate to true, then we proceed with the
  *** corresponding expression.
  rl [norm-if] :
    < P | exp: if atom("true") -> EX ; CLSEQ end, EXSEQ, ASET > =>
    < P | exp: EX, EXSEQ, ASET > [print P " norm-if1" ] .

  *** Case 2: the if clause has evaluate to false, then we proceed with the
  *** remaining clauses.
  eq [norm-if] :
     < P | exp: if atom("false") -> EX ; CLSEQ end, EXSEQ, ASET > =
     < P | exp: if CLSEQ end, EXSEQ, ASET > [print P " norm-if2" ] .

  *** Case 3: the if clause has evaluate to true and it is the last claude,
  ***  then we proceed with the corresponding expression.
  eq [norm-if] :
     < P | exp: if atom("true") -> EX  end, EXSEQ, ASET > =
     < P | exp: EX, EXSEQ, ASET > [print P " norm-if3" ] .

  *** Case 4: the if clause has evaluate to false and it is the last one, then
  *** we need to raise an error.
  eq [norm-if] :
     < P | exp: if atom("false") -> EX end, EXSEQ, ASET > =
     < P | exp: atom("error_no_true_case_inside_if"), EXSEQ, ASET > [print P " norm-if4" ] .

  *** Case 1: VAR is an unbound variable, in such case we bind it to the ground-value
  *** produced by the evaluation of EX, we update the store and we return the ground value
  ceq [norm-match] :
     < P | exp: VAR = EX, EXSEQ, store: STORE, ASET > =
     < P | exp: EX, VAR = #hole, EXSEQ, store: STORE, ASET >
     if STORE[VAR] == undefined .

  ceq [norm-match] :
     < P | exp: GVALUE, VAR = #hole, EXSEQ, store: STORE, ASET > =
     < P | exp: EXSEQ, store: STORE', ASET >
     if STORE' :=  insert(VAR, GVALUE, STORE) [print "DAghe"] .

  *** Case 1: If we try to evaluate a var which is available in the store
  *** then its value is returned.
  ceq [var-evaluation] :
     < P | exp: VAR, EXSEQ, store: STORE, ASET > =
     < P | exp: GVALUE, EXSEQ, store: STORE, ASET >
     if STORE[VAR] =/= undefined /\ GVALUE := STORE[VAR] .

  *** Case 2: If we try to evaluate a var which is not available in the store then
  *** we enter an error state.
  ceq [var-evaluation] :
     < P | exp: VAR, EXSEQ, store: STORE, ASET > =
     < P | exp: #crashed, store: STORE, ASET >
     if STORE[VAR] == undefined .

  eq < P | exp: GVALUE, EXSEQ, store: STORE, ASET > =
     < P | exp: EXSEQ, store: STORE, ASET > [owise] .
endm
``
