----------------------------------------------------------------------------------------------------
---
--- PRINT-SYNTAX-ERROR
---
--- Some functions to print out the position at which a syntax error is reported by
--- the metaParse function. This code is taken from the Full-Mode implementation.
---
----------------------------------------------------------------------------------------------------

fmod PRINT-SYNTAX-ERROR is
	protecting META-LEVEL .
	protecting INT .

	var  QIL : QidList .
	var  Q : Qid .
	var  N : Nat .
	vars RP RP' : ResultPair .
	var  RP? : [ResultPair?] .

	op printN : Nat QidList -> QidList .  *** first N qid's in a qidList
	eq printN(N, nil) = nil .
	eq printN(0, QIL) = nil .
	eq printN(s N, Q QIL) = Q printN(N, QIL) .

	op removeFront : Nat QidList -> QidList .  *** removes first N qid's
	eq removeFront(N, nil) = nil .
	eq removeFront(0, QIL) = QIL .
	eq removeFront(s N, Q QIL) = removeFront(N, QIL) .

	op printSyntaxError : [ResultPair?] QidList -> QidList .
	eq printSyntaxError(noParse(N), QIL)
		= '\r 'Parse 'error 'in '\o '\s printN(N + 1, QIL) '\r '<---*HERE* '\o .
	eq printSyntaxError(ambiguity(RP, RP'), QIL)
		= '\r 'Ambiguous 'parsing 'for '\o '\s QIL '\o .
	eq printSyntaxError(RP?, QIL) = QIL [owise] .
endfm

----------------------------------------------------------------------------------------------------
---
--- SYNTAX-HELPER
---
----------------------------------------------------------------------------------------------------

fmod SYNTAX-HELPER is 
	protecting RAT .
	protecting FLOAT .
	protecting INT .
	protecting STRING .
	protecting CONVERSION .
	protecting QID .
	protecting META-LEVEL .

	*** core-erlang atoms
	op syntaxCheckAtom : Term -> Bool .
	op getAtom : Term -> String .
	
	*** core-erlang variable names
	op syntaxCheckVar : Term -> Bool .
	op getVar : Term -> String .
	
	*** core-erlang characters
	op syntaxCheckChar : Term -> Bool .
	op getChar : Term -> Char .
	
	*** core-erlang strings
	op syntaxCheckString : Term -> Bool .
	op getString : Term -> String .
	
	*** core-erlang integers
	op syntaxCheckInt : Term -> Bool .
	op getInt : Term -> Int .

	*** core-erlang floats
	op syntaxCheckFloat : Term -> Bool .
	op getFloat : Term -> Float .

	sort CharSet .
	subsort Char < CharSet .
	op _,_ : CharSet CharSet -> CharSet [ctor comm assoc] .
	op intCharSet : -> CharSet .
	op signCharSet : -> CharSet .
	op stringCharSet : -> CharSet .
	op characterSet : String CharSet -> Bool .

	op downQid : Qid -> Qid .
		
	var Str : String .
	var T : Term .
	var QID : Qid .
	var EndPos : Int .
	var Chr Chr1 Chr2 : Char .
	var Set : CharSet .

	eq intCharSet = "0","1","2","3","4","5","6","7","8","9" .
	eq signCharSet = "-", "+" .
	
	eq characterSet("", Set) = true .
	eq characterSet(Chr, Chr1) = if (Chr == Chr1) then true else false fi .
	eq characterSet(Chr, (Chr1, Set)) = if (Chr == Chr1) then true else characterSet(Chr, Set) fi .
	eq characterSet(Str, Set) = 
		if characterSet(substr(Str, 0, 1), Set) then characterSet(substr(Str, 1, length(Str) + (-1)), Set) else false fi .

	ceq downQid( QID ) = qid(substr(Str, 1, length(Str))) 
		if Str := string(QID) /\ substr(Str, 0, 1) == "'" .

	*** core-erlang atoms
	ceq syntaxCheckAtom('token[T]) = (substr(Str, 0, 1) == "'") and (substr(Str, EndPos, 1) == "'") 
		if Str := string(downQid(getName(T))) /\ EndPos := length(Str) + (-1) .
	ceq getAtom('token[T]) = substr(Str, 1, EndPos) 
	  	if Str := string(downQid(getName(T))) /\ EndPos := length(Str) + (-2) /\ syntaxCheckAtom('token[T]) .
	  
	*** core-erlang variable names
	ceq syntaxCheckVar('token[T]) = ((ascii(Chr) >= 65) and (ascii(Chr) <= 90)) or (ascii(Chr) == 95)
	  	if Chr := substr(string(downQid(getName(T))), 0, 1) .
	ceq getVar('token[T]) = string(downQid(getName(T))) 
	  	if syntaxCheckVar('token[T]) .
	  
	*** core-erlang characters
	ceq syntaxCheckChar('token[T]) = (substr(Str, 0, 1) == "'") and (substr(Str, 2, 1) == "'") 
	  	if Str := string(downQid(getName(T))) /\ (length(Str) == 2) .
	ceq getChar('token[T]) = substr(Str, 1, 1) 
	  	if Str := string(downQid(getName(T))) /\ syntaxCheckAtom('token[T]) .
	
	*** core-erlang strings
	ceq syntaxCheckString('token[T]) = (substr(Str, 0, 1) == "\"") and (substr(Str, EndPos, 1) == "\"")
		if Str := string(downQid(getName(T))) /\ EndPos := length(Str) + (-1) .
	ceq getString('token[T]) = string(downQid(getName(T))) 
		if syntaxCheckString('token[T]) .	
	  
	*** core-erlang integers
	ceq syntaxCheckInt('token[T]) = (characterSet(substr(Str, 0, 1), signCharSet) and characterSet(substr(Str, 1, length(Str) + (-1)), intCharSet)) 
	                                 or (characterSet(substr(Str,0,length(Str)), intCharSet)) 
		if Str := string(downQid(getName(T))) .
	ceq getInt('token[T]) = rat(string(downQid(getName(T))),10) 
		if syntaxCheckInt('token[T]) .		
	
	*** core-erlang floats 
	*** - not implemented -
	
	*** core-erlang token lists
	*** - not implemented -
endfm



fmod COMMON-SYNTAX-DOWN is
	protecting SYNTAX .
	protecting QID .
	protecting META-TERM .
	protecting META-LEVEL .
	protecting STRING .
	protecting INT .
	protecting CONVERSION .

	op GRAMMAR : -> FModule .

  op #downProgram : Term -> Program [memo] .

  op #downAtom : Term -> Atom [memo] .
	op #downErlInt : Term -> ErlInt [memo] .

  op #downIf : Term -> If [memo] .
  op #downClause : Term -> Clause [memo] .
  op #downClauseSeq : Term -> ClauseSeq [memo] .

  op #downExp : Term -> Exp [memo] .

  op #downList : Term -> List [memo] .

  op #downFunCall : Term -> FunCall [memo] .
  op #downFunDef : Term -> FunDef [memo] .
  op #downFunDefSeq : Term -> FunDefSeq [memo] .

  op #downSend : Term -> Send [memo] .

  op #downReceive : Term -> Receive [memo] .

	vars T T1 T2 T3 T4 : Term .
	var SUB : Substitution .
  var FDEF : FunDef .
  var FDEFSEQ : FunDefSeq .

  eq #downProgram(T) = #downExp(T) .

  *** LIST

  eq #downList('`[`].Nil) = [] .
  eq #downList('`[_`][T1]) = [#downExp(T1)] .
  eq #downList('`[_|_`][T1,T2]) = [ #downExp(T1) | #downExp(T2)] .

  *** EXP
  eq #downExp('`[`].Nil) = #downList('`[`].Nil) .
	eq #downExp('`[_`][T1]) = #downList('`[_`][T1]) .
	eq #downExp('`[_|_`][T1,T2]) = #downList('`[_|_`][T1,T2]) .

  eq #downExp('if_end[T1]) = #downIf('if_end[T1]) .

  eq #downExp('_`(`)[T]) = #downFunCall('_`(`)[T]) .
  eq #downExp('_`(_`)[T1,T2]) = #downFunCall('_`(_`)[T1,T2]) .
  eq #downExp('_:_`(_`)[T1,T2,T3]) = #downFunCall('_:_`(_`)[T1,T2,T3]) .

  eq #downExp('_!_[T1,T2]) =  #downSend('_!_[T1,T2]) .

  eq #downExp('receive_end[T]) = #downReceive('receive_end[T]) .

	ceq #downExp(T1) = #downExp(T2), #downExp(T3)
		if SUB := metaMatch(GRAMMAR, '_`,_['E:Exp, 'EL:Exp], T1, nil, 0)
		/\ 'E:Exp <- T2 ; 'EL:Exp <- T3 := SUB .

  *** IF
  eq #downIf('if_end[T1]) = if #downClauseSeq(T1) end .

  *** CLAUSE
  eq #downClause('_->_[T1,T2]) = #downExp(T1) -> #downExp(T2) .

  ceq #downClauseSeq(T1) = #downClause(T2) ; #downClauseSeq(T3)
     if SUB := metaMatch(GRAMMAR, '_;_['CL:Clause, 'CLSEQ:ClauseSeq], T1, nil, 0)
     /\ 'CL:Clause <- T2 ; 'CLSEQ:ClauseSeq <- T3 := SUB .
  eq #downClauseSeq(T1) = #downClause(T1) [owise] .

  *** FUN
  eq #downFunDef('fun_`(`)->_.[T1,T2]) = fun #downExp(T1)()-> #downExp(T2) . .

  ceq #downFunDefSeq(T1) = #downFunDef(T2) #downFunDefSeq(T3)
     if SUB := metaMatch(GRAMMAR, '__['FDEF:FunDef, 'FDEFSEQ:FunDefSeq], T1, nil, 0)
     /\ 'FDEF:FunDef <- T2 ; 'FDEFSEQ:FunDefSeq <- T3 := SUB .

  eq #downFunDefSeq(T) = #downFunDef(T) [owise] .

  eq #downFunCall('_`(`)[T]) = #downExp(T)() .
  eq #downFunCall('_`(_`)[T1, T2]) = _`(_`)(#downExp(T1),#downExp(T2)) .
  eq #downFunCall('_:_`(_`)[T1,T2,T3]) = #downExp(T1) : #downExp(T2) (#downExp(T3)) .

  *** SEND
  eq #downSend('_!_[T1,T2]) = #downExp(T1) ! #downExp(T2) .

  *** RECEIVE
  eq #downReceive('receive_end[T]) = receive #downClauseSeq(T) end .

endfm

fmod PARSING-SYNTAX-DOWN is
  protecting META-UP-DOWN .
  protecting SYNTAX-HELPER .
	including COMMON-SYNTAX-DOWN .

	op #downErlString : Term -> Exp [memo]  .
	op #downErlChar : Term -> ErlInt [memo] .

	eq GRAMMAR =
		(mod 'GRAMMAR is
			including 'QID-LIST .
			including 'COMMAND-GRAMMAR .
			including 'PARSING-SYNTAX .
      including 'SEM_PROCESSESENVIRONMENT .
      including 'SEM_MODENV .
			sorts none .
			none
			op 'token : 'Qid -> 'Token
				[ctor special(
					(id-hook('Bubble, '1 '1)
					 op-hook('qidSymbol, '<Qids>, nil, 'Qid)
					 id-hook('Exclude, 'if 'end '; '-> '`[ '`] '< '> '`(`) '`. '`( '`) )))
				format ('b 'o)] .
			none
			none
			none
		endm) .

	var T : Term .

  eq #downAtom('token[T]) = atom(substr(string(getName(T)), 1, length(string(getName(T))) + (-1))) .
	eq #downErlInt('token[T]) = int(rat(substr(string(getName(T)), 1, length(string(getName(T)))), 10)) .


	ceq #downExp('token[T]) = #downErlInt('token[T])
		if syntaxCheckInt('token[T]) .
	eq #downExp('token[T]) = #downAtom('token[T]) [owise] .



endfm

fmod MAUDE-SYNTAX-DOWN is
	protecting META-UP-DOWN .
	including COMMON-SYNTAX-DOWN .

	eq GRAMMAR =
		(mod 'GRAMMAR is
			including 'QID-LIST .
			including 'SYNTAX .
			including 'SEM_PROCESS .
			sorts none .
			none
			none
			none
			none
			none
		endm) .

	var T : Term .

	eq #downAtom('atom[T]) = atom(#downString(T)) .
	eq #downErlInt('int[T]) = int(#downInt(T)) .

	eq #downExp('atom[T]) = atom(#downString(T)) .
	eq #downExp('int[T]) = int(#downInt(T)) .
endfm


fmod MAUDE-SYNTAX-UPDOWN is
	protecting MAUDE-SYNTAX-UP .
	protecting MAUDE-SYNTAX-DOWN .
endfm
